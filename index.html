<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Tiny DOOM-ish — Polished</title>
<style>
  :root{
    --bg:#0c0f14; --fg:#e9eef6; --accent:#7cf; --warn:#ff7a7a;
    --glass:rgba(15,18,24,.45); --glass-b:rgba(255,255,255,.06);
  }
  *{box-sizing:border-box}
  html,body{
    margin:0;height:100%;background:var(--bg);color:var(--fg);
    font:14px/1.45 system-ui,Segoe UI,Roboto,Arial,sans-serif;overflow:hidden;
    -webkit-user-select:none;user-select:none;touch-action:none;
  }
  header{
    position:fixed;inset:0 0 auto 0;padding:10px 12px;z-index:5;
    display:flex;align-items:center;justify-content:space-between;
    background:linear-gradient(#0d1117,#0a0d12);
    border-bottom:1px solid #12161d
  }
  header .title{font-weight:700;letter-spacing:.3px}
  header .hint{opacity:.75;font-size:12px}
  #canvas{display:block;width:100vw;height:100vh}
  #hud{
    position:fixed;left:10px;top:52px;z-index:4;
    background:var(--glass);border:1px solid var(--glass-b);
    border-radius:10px;padding:6px 10px;font-size:12px
  }
  #mini{
    position:fixed;right:10px;top:56px;width:160px;height:160px;border-radius:10px;
    background:var(--glass);border:1px solid var(--glass-b);overflow:hidden;z-index:3
  }
  @media (max-width:900px){#mini{width:120px;height:120px}}
  /* Simple “gun” overlay */
  #gun{
    position:fixed;left:50%;bottom:0;transform:translateX(-50%);
    width:min(40vw,420px);height:120px;pointer-events:none;z-index:6;
  }
  #gun .barrel{
    position:absolute;left:50%;bottom:18px;transform:translateX(-50%);
    width:86px;height:52px;border-radius:12px;
    background:linear-gradient(180deg,#1e232c,#12161d);
    border:1px solid #2a3040;box-shadow:inset 0 10px 20px rgba(255,255,255,.05)
  }
  #gun .grip{
    position:absolute;left:50%;bottom:0;transform:translateX(-50%);
    width:180px;height:26px;border-radius:16px 16px 0 0;
    background:linear-gradient(180deg,#1a1f27,#0f131a);border:1px solid #2a3040
  }
  #muzzle{
    position:fixed;left:50%;bottom:95px;transform:translateX(-50%);
    width:20px;height:20px;border-radius:50%;filter:blur(2px);display:none;z-index:7;
    background:radial-gradient(circle,#ffd9a6,#ff9f3a 45%, transparent 60%);
  }
  /* Mobile pad (kept small) */
  #controls{position:fixed;inset:0;pointer-events:none;z-index:7}
  .pad{position:absolute;bottom:14px;width:min(44vw,330px);aspect-ratio:16/9;max-width:330px;
    pointer-events:auto;display:grid;grid-template-columns:repeat(3,1fr);grid-template-rows:repeat(2,1fr);
    gap:8px;padding:8px;border-radius:14px;background:var(--glass);backdrop-filter:blur(6px);
    border:1px solid var(--glass-b)
  }
  .pad.left{left:10px}
  .pad.right{right:10px}
  .btn{display:flex;align-items:center;justify-content:center;border-radius:12px;
    background:linear-gradient(180deg,#1c2129,#141920);border:1px solid #2a3040;
    color:#cfe3ff;text-shadow:0 1px 0 rgba(0,0,0,.6);font-weight:600}
  .btn:active{transform:translateY(1px);filter:brightness(.95)}
  .btn.fire{grid-column:1/4;background:linear-gradient(180deg,#3a0d0d,#260909);color:#ffc9c9;border-color:#4a1313}
  .btn span{pointer-events:none}
</style>
</head>
<body>
<header>
  <div class="title">Tiny DOOM-ish</div>
  <div class="hint">W/S move • A/D turn • Q/E strafe • Click/Space fire • Drag / ←→ look</div>
</header>

<canvas id="canvas"></canvas>
<canvas id="mini" width="160" height="160"></canvas>
<div id="hud">—</div>

<!-- Light “gun” UI -->
<div id="gun" aria-hidden="true"><div class="barrel"></div><div class="grip"></div></div>
<div id="muzzle"></div>

<!-- Mobile controls -->
<div id="controls" aria-hidden="false">
  <div class="pad left">
    <div class="btn" data-act="moveF"><span>↑</span></div>
    <div class="btn" data-act="moveB"><span>↓</span></div>
    <div class="btn" data-act="strafeL"><span>⟵</span></div>
    <div class="btn" data-act="strafeR"><span>⟶</span></div>
    <div class="btn" data-act="turnL"><span>⟲</span></div>
    <div class="btn" data-act="turnR"><span>⟳</span></div>
  </div>
  <div class="pad right">
    <div class="btn fire" data-act="fire"><span>FIRE</span></div>
    <div class="btn" data-act="look"><span>DRAG to LOOK</span></div>
    <div class="btn" data-act="noop"></div>
    <div class="btn" data-act="noop"></div>
    <div class="btn" data-act="noop"></div>
    <div class="btn" data-act="noop"></div>
  </div>
</div>

<script>
(() => {
  // --- DOM / ctx
  const cvs = document.getElementById('canvas');
  const ctx = cvs.getContext('2d');
  const mini = document.getElementById('mini');
  const mctx = mini.getContext('2d');
  const hud = document.getElementById('hud');
  const muzzle = document.getElementById('muzzle');

  // --- Config
  const FOV = Math.PI/3;             // 60°
  const MAX_DEPTH = 20;
  const MOVE = 3.0, STRAFE = 2.4, ROT = 2.4;
  const BULLET_COOLDOWN = 0.18;
  const ENEMY_SPEED = 0.9, ENEMY_HITBOX = 0.35;

  // --- Map
  const MAP = [
    '111111111111111111',
    '1....1.......2...1',
    '1..111..1........1',
    '1..1....1..11....1',
    '1..1....1........1',
    '1..1....1111.....1',
    '1............3...1',
    '1..1111..........1',
    '1..1..1..111.....1',
    '1..1..1..........1',
    '1..1..1111..111..1',
    '1............1...1',
    '1..2........1...31',
    '1...........1....1',
    '1....111.........1',
    '1..............E.1',
    '1................1',
    '111111111111111111',
  ].map(r=>r.split(''));
  const H = MAP.length, W = MAP[0].length;

  // --- Enemies
  const enemies=[];
  for(let y=0;y<H;y++)for(let x=0;x<W;x++){
    const t=MAP[y][x];
    if(t==='2'||t==='3'||t==='E'){
      enemies.push({x:x+0.5,y:y+0.5,hp:t==='E'?5:t==='3'?3:2,color:t==='E'?'#ff4d4d':t==='3'?'#ff8844':'#ffaa33',hitFlash:0});
      MAP[y][x]='.';
    }
  }

  // --- Player
  const player={x:2.5,y:2.5,angle:0,hp:100,ammo:99,lastShot:-999};

  // --- Input
  const keys={w:false,s:false,strafeL:false,strafeR:false,left:false,right:false,fire:false};
  let dragging=false,lastDragX=null;

  // --- Tracers & Particles
  const tracers=[]; // {ttl, width, alpha}
  const sparks=[];  // {ttl, xScreen, yScreen}
  let shake=0;

  // --- Helpers
  function resize(){
    const dpr=Math.max(1,window.devicePixelRatio||1);
    const hHeader=42;
    cvs.width=Math.floor(window.innerWidth*dpr);
    cvs.height=Math.floor((window.innerHeight-hHeader)*dpr);
    cvs.style.width=window.innerWidth+'px';
    cvs.style.height=(window.innerHeight-hHeader)+'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize',resize); resize();

  function isWall(x,y){
    const xi=Math.floor(x), yi=Math.floor(y);
    if(yi<0||yi>=H||xi<0||xi>=W) return true;
    return MAP[yi][xi]==='1';
  }
  function cast(px,py,ang){
    const sin=Math.sin(ang), cos=Math.cos(ang);
    let d=0, hx=px, hy=py, side=0;
    while(d<MAX_DEPTH){
      d+=0.01; hx=px+cos*d; hy=py+sin*d;
      if(isWall(hx,hy)){
        const fx=hx-Math.floor(hx), fy=hy-Math.floor(hy);
        side=(fx<.02||fx>.98)?1:(fy<.02||fy>.98)?0:.5;
        break;
      }
    }
    return {dist:d,hitX:hx,hitY:hy,side};
  }
  function canMove(nx,ny){
    const pad=.2;
    return !(isWall(nx-pad,ny-pad)||isWall(nx+pad,ny-pad)||isWall(nx-pad,ny+pad)||isWall(nx+pad,ny+pad));
  }

  // --- Shooting + FX
  function tryShoot(tNow){
    if(tNow - player.lastShot < BULLET_COOLDOWN || player.ammo<=0) return;
    player.lastShot=tNow; player.ammo--;
    // muzzle flash
    muzzle.style.display='block';
    setTimeout(()=>muzzle.style.display='none',70);
    shake = 5;

    // hitscan: choose closest enemy along center cone; else wall
    let hitEnemy=null,hitIdx=-1,hitDist=Infinity;
    const half=FOV*.5;
    enemies.forEach((e,i)=>{
      const dx=e.x-player.x, dy=e.y-player.y;
      const dist=Math.hypot(dx,dy); if(dist>MAX_DEPTH) return;
      let ang=Math.atan2(dy,dx)-player.angle;
      ang=(ang+Math.PI*3)%(Math.PI*2)-Math.PI;
      if(Math.abs(ang) < half*0.35){
        // line-of-sight
        const steps=Math.ceil(dist/0.05); let blocked=false;
        for(let s=1;s<=steps;s++){
          const tx=player.x + dx*s/steps, ty=player.y + dy*s/steps;
          if(isWall(tx,ty)){ blocked=true; break; }
        }
        if(!blocked && dist < hitDist){ hitDist=dist; hitEnemy=e; hitIdx=i; }
      }
    });

    let impactDist;
    if(hitEnemy){
      hitEnemy.hp -= 1; hitEnemy.hitFlash=0.12;
      if(hitEnemy.hp<=0) enemies.splice(hitIdx,1);
      impactDist = hitDist;
      addSparkCenter();
    } else {
      const r = cast(player.x,player.y,player.angle);
      impactDist = r.dist;
      addSparkCenter();
    }
    // visual tracer from crosshair
    tracers.push({ttl:0.12, width:3, alpha:0.9});
  }

  // simple screen-center spark (fake but effective)
  function addSparkCenter(){ sparks.push({ttl:0.18}); }

  // --- Enemies AI
  function updateEnemies(dt){
    enemies.forEach(e=>{
      const dx=player.x-e.x, dy=player.y-e.y;
      const dist=Math.hypot(dx,dy);
      if(dist>0.001){
        const step=Math.min(ENEMY_SPEED*dt, dist-0.001);
        const nx=e.x + (dx/dist)*step*.6;
        const ny=e.y + (dy/dist)*step*.6;
        if(!isWall(nx,e.y)) e.x=nx;
        if(!isWall(e.x,ny)) e.y=ny;
      }
      if(dist < ENEMY_HITBOX+.2) player.hp = Math.max(0, player.hp - 10*dt);
      if(e.hitFlash>0) e.hitFlash = Math.max(0, e.hitFlash - dt);
    });
  }

  // --- Input
  window.addEventListener('keydown',e=>{
    if(e.code==='KeyW') keys.w=true;
    if(e.code==='KeyS') keys.s=true;
    if(e.code==='KeyA') keys.left=true;
    if(e.code==='KeyD') keys.right=true;
    if(e.code==='KeyQ') keys.strafeL=true;
    if(e.code==='KeyE') keys.strafeR=true;
    if(e.code==='ArrowLeft') keys.left=true;
    if(e.code==='ArrowRight') keys.right=true;
    if(e.code==='Space'){ keys.fire=true; e.preventDefault(); }
  });
  window.addEventListener('keyup',e=>{
    if(e.code==='KeyW') keys.w=false;
    if(e.code==='KeyS') keys.s=false;
    if(e.code==='KeyA') keys.left=false;
    if(e.code==='KeyD') keys.right=false;
    if(e.code==='KeyQ') keys.strafeL=false;
    if(e.code==='KeyE') keys.strafeR=false;
    if(e.code==='ArrowLeft') keys.left=false;
    if(e.code==='ArrowRight') keys.right=false;
    if(e.code==='Space') keys.fire=false;
  });
  cvs.addEventListener('mousedown',e=>{ dragging=true; lastDragX=e.clientX; });
  window.addEventListener('mouseup',()=>{ dragging=false; lastDragX=null; });
  window.addEventListener('mousemove',e=>{
    if(!dragging) return;
    if(lastDragX!=null) player.angle += (e.clientX-lastDragX)*0.003;
    lastDragX=e.clientX;
  });
  // click to fire
  cvs.addEventListener('click',()=>tryShoot(performance.now()/1000));
  window.addEventListener('contextmenu',e=>e.preventDefault());

  // Touch controls
  const controls=document.getElementById('controls');
  controls.addEventListener('touchstart', onTouch, {passive:false});
  controls.addEventListener('touchend', onTouchEnd, {passive:false});
  controls.addEventListener('touchmove', onTouchMove, {passive:false});
  let touchLookId=null,touchLookLastX=null;
  function onTouch(e){
    for(const t of e.changedTouches){
      const el=document.elementFromPoint(t.clientX,t.clientY);
      if(!el||!el.dataset) continue;
      const a=el.dataset.act; if(!a) continue;
      if(a==='fire') keys.fire=true;
      if(a==='moveF') keys.w=true;
      if(a==='moveB') keys.s=true;
      if(a==='strafeL') keys.strafeL=true;
      if(a==='strafeR') keys.strafeR=true;
      if(a==='turnL') keys.left=true;
      if(a==='turnR') keys.right=true;
      if(a==='look'){ touchLookId=t.identifier; touchLookLastX=t.clientX; }
    }
    e.preventDefault();
  }
  function onTouchMove(e){
    for(const t of e.changedTouches){
      if(t.identifier===touchLookId && touchLookLastX!=null){
        player.angle += (t.clientX - touchLookLastX)*0.004;
        touchLookLastX=t.clientX;
      }
    }
    e.preventDefault();
  }
  function onTouchEnd(e){
    keys.fire=false; keys.w=false; keys.s=false; keys.strafeL=false; keys.strafeR=false; keys.left=false; keys.right=false;
    for(const t of e.changedTouches) if(t.identifier===touchLookId){ touchLookId=null; touchLookLastX=null; }
    e.preventDefault();
  }

  // --- Loop
  let last=performance.now()/1000;
  function step(){
    const now=performance.now()/1000;
    const dt=Math.min(0.033, now-last); last=now;

    // Move
    let mx=0,my=0; const c=Math.cos(player.angle), s=Math.sin(player.angle);
    if(keys.w){ mx+=c*MOVE*dt; my+=s*MOVE*dt; }
    if(keys.s){ mx-=c*MOVE*dt; my-=s*MOVE*dt; }
    if(keys.strafeL){ mx+=-s*STRAFE*dt; my+= c*STRAFE*dt; }
    if(keys.strafeR){ mx+= s*STRAFE*dt; my+=-c*STRAFE*dt; }
    const nx=player.x+mx, ny=player.y+my;
    if(canMove(nx,player.y)) player.x=nx;
    if(canMove(player.x,ny)) player.y=ny;
    if(keys.left)  player.angle -= ROT*dt;
    if(keys.right) player.angle += ROT*dt;

    if(keys.fire) tryShoot(now);

    updateEnemies(dt);
    updateFX(dt);
    render();

    requestAnimationFrame(step);
  }

  function updateFX(dt){
    for(const t of tracers){ t.ttl-=dt; t.width = Math.max(0, t.width - dt*28); t.alpha = Math.max(0, t.alpha - dt*8); }
    while(tracers.length && tracers[0].ttl<=0) tracers.shift();
    for(const p of sparks){ p.ttl-=dt; }
    while(sparks.length && sparks[0].ttl<=0) sparks.shift();
    if(shake>0) shake*=0.88;
  }

  // --- Render
  function render(){
    const w=cvs.clientWidth, h=cvs.clientHeight, half=h>>1;

    // backdrop
    const gTop=ctx.createLinearGradient(0,0,0,half);
    gTop.addColorStop(0,'#0a0f18'); gTop.addColorStop(1,'#0d1118');
    ctx.fillStyle=gTop; ctx.fillRect(0,0,w,half);
    const gBot=ctx.createLinearGradient(0,half,0,h);
    gBot.addColorStop(0,'#0d1118'); gBot.addColorStop(1,'#0f141c');
    ctx.fillStyle=gBot; ctx.fillRect(0,half,w,h-half);

    if(shake>0){ ctx.save(); ctx.translate((Math.random()-.5)*shake,(Math.random()-.5)*shake); }

    // walls via rays
    const rays=Math.floor(180*(w/800));
    const colW=w/rays, start=player.angle - FOV/2;
    for(let i=0;i<rays;i++){
      const ang = start + (i/rays)*FOV;
      const {dist,side} = cast(player.x,player.y,ang);
      const corrected = dist*Math.cos(ang-player.angle);
      const wallH = Math.min(h, (1/corrected) * (h/(2*Math.tan(FOV/2))));
      const shade = Math.max(0, 1 - corrected/MAX_DEPTH);
      const wallCol = side<.5 ? 170 : 200;
      ctx.fillStyle = `rgba(${wallCol},${Math.floor(120+50*shade)},${Math.floor(140+20*shade)},.88)`;
      const x=Math.floor(i*colW);
      ctx.fillRect(x, (half-wallH/2), Math.ceil(colW+1), wallH);
      ctx.fillStyle = `rgba(0,0,0,${Math.min(.25, .005*corrected)})`;
      ctx.fillRect(x,0,1,h);
    }

    // enemies (billboards)
    const spr = enemies.map(e=>{
      const dx=e.x-player.x, dy=e.y-player.y;
      const dist=Math.hypot(dx,dy); let ang=Math.atan2(dy,dx)-player.angle;
      ang=(ang+Math.PI*3)%(Math.PI*2)-Math.PI;
      return {e,dist,ang};
    }).filter(s=>Math.abs(s.ang)<FOV/1.1).sort((a,b)=>b.dist-a.dist);

    spr.forEach(s=>{
      const {e,dist,ang}=s;
      const size = Math.min(h, (1.4 / dist) * (h/(2*Math.tan(FOV/2))) * 1.8);
      const x=(ang/FOV + .5)*w, y=(h/2)-size*.9;
      const alpha=Math.max(.2, 1 - dist/(MAX_DEPTH*.9));
      ctx.fillStyle = e.hitFlash>0 ? 'rgba(255,240,120,.95)' : `rgba(${hex2rgb(e.color)},${alpha})`;
      ctx.fillRect(x-size/2, y, size, size);
      ctx.fillStyle = `rgba(0,0,0,${Math.min(.5, .2 + dist*0.02)})`;
      ctx.fillRect(x-size/2, y+size*.4, size, size*.15);
    });

    // bullet tracer(s)
    for(const t of tracers){
      const a = Math.max(0, t.alpha);
      ctx.strokeStyle = `rgba(255,230,160,${a})`;
      ctx.lineWidth = Math.max(1, t.width);
      ctx.beginPath();
      ctx.moveTo(w/2, h/2);
      ctx.lineTo(w/2, h/2 - Math.min(h*0.35, h*0.12 + 90*t.alpha)); // short beam forward
      ctx.stroke();
    }

    // hit spark at crosshair
    for(const p of sparks){
      const r = 3 + 14*p.ttl;
      ctx.fillStyle='rgba(255,220,120,.85)';
      ctx.beginPath(); ctx.arc(w/2, h/2 - 18, r, 0, Math.PI*2); ctx.fill();
    }

    // crosshair
    ctx.strokeStyle='rgba(255,255,255,.5)'; ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(w/2-10,h/2); ctx.lineTo(w/2+10,h/2);
    ctx.moveTo(w/2,h/2-10); ctx.lineTo(w/2,h/2+10);
    ctx.stroke();

    if(shake>0) ctx.restore();

    // HUD + minimap
    hud.textContent = `HP ${Math.round(player.hp)} • Ammo ${player.ammo} • Demons ${enemies.length}`;
    renderMini();
  }

  function renderMini(){
    const mw=mini.width, mh=mini.height;
    mctx.clearRect(0,0,mw,mh);
    const cx=mw/W, cy=mh/H;
    for(let y=0;y<H;y++)for(let x=0;x<W;x++){
      mctx.fillStyle = MAP[y][x]==='1' ? '#3a3f47' : '#13161b';
      mctx.fillRect(x*cx,y*cy,cx,cy);
    }
    enemies.forEach(e=>{
      mctx.fillStyle='#ff6464'; mctx.beginPath(); mctx.arc(e.x*cx, e.y*cy, 3, 0, Math.PI*2); mctx.fill();
    });
    mctx.fillStyle='#9ee37d'; mctx.beginPath(); mctx.arc(player.x*cx, player.y*cy, 3, 0, Math.PI*2); mctx.fill();
    mctx.strokeStyle='#9ee37d'; mctx.beginPath();
    mctx.moveTo(player.x*cx, player.y*cy);
    mctx.lineTo((player.x+Math.cos(player.angle)*.8)*cx, (player.y+Math.sin(player.angle)*.8)*cy);
    mctx.stroke();
  }

  function hex2rgb(hex){ const r=parseInt(hex.slice(1,3),16), g=parseInt(hex.slice(3,5),16), b=parseInt(hex.slice(5,7),16); return `${r},${g},${b}`; }

  requestAnimationFrame(step);
})();
</script>
</body>
</html>
